from __future__ import annotations  # noqa
from copy import deepcopy
from typing import Type, Optional, List, Callable
from pathlib import Path
from textwrap import dedent
import warnings

import numpy as np
from numpy.typing import ArrayLike
import xarray as xr
import matplotlib.pyplot as plt
from omas import identify_cocos, cocos_transform

from pyrokinetics.dataset_wrapper import DatasetWrapper
from pyrokinetics.readers import Reader, create_reader_factory
from pyrokinetics.typing import PathLike
from pyrokinetics.units import ureg as units
from pyrokinetics._version import __version__
from .flux_surface import _flux_surface_contour, FluxSurface
from .utils import eq_units, UnitSpline, UnitSpline2D


class EquilibriumCOCOSWarning(UserWarning):
    pass


class Equilibrium(DatasetWrapper):
    r"""
    Contains a solution of the Grad-Shafranov equation, which defines a tokamak plasma
    equilibrium. Users are not expected to initialise ``Equilibrium`` objects directly,
    and in most cases should instead make use of the function ``read_equilibrium``,
    which can read popular plasma equilibrium file types such as GEQDSK, generated by
    tools such as FreeGS_ and EFIT_, or netCDF4 files generated by TRANSP_ or VMEC_.

    The user may specify the COCOS convention followed by their inputs. Alternatively,
    If supplied with ``b_axis``, ``current``, and (optionally) ``clockwise_phi``, inputs
    will be converted to the convention COCOS 1. Otherwise, it is assumed that the
    inputs are already COCOS 1.


    .. _FreeGS: https://github.com/freegs-plasma/freegs
    .. _EFIT: https://omfit.io/modules/mod_EFIT++.html
    .. _TRANSP: https://transp.pppl.gov/
    .. _VMEC: https://princetonuniversity.github.io/STELLOPT/VMEC

    Parameters
    ----------

    R: ArrayLike, units [meter]
        Linearly spaced and monotonically increasing 1D grid of major radius
        coordinates. This is the radius from the central column of a tokamak, and not
        the radial distance from the magnetic axis.
    Z: ArrayLike, units [meter]
        Linearly spaced and monotonically increasing 1D grid of tokamak z-coordinates.
        This is usually the height above the plasma midplane, but z=0 may be set at any
        reference point.
    psi_RZ: ArrayLike, units [weber / radian]
        2D grid defining the poloidal magnetic flux function :math::`\psi` with respect
        to ``R`` and ``Z``. Should have the shape ``(len(r), len(z))``. If supplied
        in units of Weber (i.e. following COCOS 11 to 18), this will be converted.
    psi: ArrayLike, units [weber / radian]
        1D grid defining the poloidal magnetic flux function. This grid defines
        magnetic flux surface coordinates, on which most other parameters are defined.
        ``psi[0]`` should be the value of ``psi`` on the magnetic axis. ``psi`` should
        be monotonically increasing or decreasing. If supplied in units of Weber
        (i.e. following COCOS 11 to 18), this will be converted.
    f: ArrayLike, units [meter * tesla]
        1D grid defining the poloidal current function with respect to ``psi``. Should
        have the same length as ``psi``.
    ff_prime: ArrayLike, units [meter**2 * tesla**2 * radian / weber]
        1D grid defining the poloidal current function ``f`` multiplied by its
        derivative with respect to ``psi``. Should have the same length as ``psi``.
    p: ArrayLike, units [pascal]
        1D grid defining the plasma pressure with respect to ``psi``. Should have the
        same length as ``psi``.
    p_prime: ArrayLike, units [pascal * radian / weber]
        1D grid defining the derivative of the plasma pressure with respect to ``psi``.
        Should have the same length as ``psi``.
    q: ArrayLike, units [dimensionless]
        1D grid defining the 'safety factor' with respect to ``psi``. Should have same
        length as ``psi``.
    R_major: ArrayLike, units [meter]
        1D grid of the major radius positions of the center of each flux surface with
        respect to ``psi``. Should have the same length as ``psi``. This should be given
        by the mean of the maximum and minimum major radii of the flux surface.
        ``R_major[0]`` should be the major radius of the magnetic axis.
    r_minor: ArrayLike, units[meter]
        1D grid of the minor radius of each flux surface with respect to ``psi``. Should
        have the same length as ``psi``. This should be half of the difference between
        the maximum and minimum major radii of a flux surface. ``r_minor[0]`` should be
        0.0.
    Z_mid: ArrayLike, units [meter]
        1D grid of the z-midpoint of each flux surface with respace to ``psi``. Should
        have the same length as ``psi``. This should be the mean of the maximum and
        minimum z-positions of the flux surface. ``Z_mid[0]`` should be the z-position
        of the magnetic axis.
    psi_lcfs: float, units [weber / radian]
        The value of ``psi`` on the last closed flux surface (LCFS).
    a_minor: float, units [meter]
        The minor radius of the last closed flux surface (LCFS). The minor radius of a
        flux surface is half of the difference between its maximum and minimum major
        radii.
    b_axis: Optional[float], units [tesla]
        Vacuum toroidal magnetic field. Used to determine COCOS convention of the
        inputs.
    current: Optional[float], units [ampere]
        Plasma current. Used to determine COCOS convention of the inputs.
    clockwise_phi: bool, default False
        Determines whether the :math:`\phi` grid increases clockwise or anti-clockwise
        when viewed from above. Used to determine COCOS convention of the inputs.
    cocos: Optional[int]
        Asserts that the inputs follow a particular COCOS convention. If set, prevents
        the automatic detection of COCOS conventions using the values of ``b_axis``,
        ``current``, ``q``, ``psi``, ``r_minor``, and ``clockwise_phi``. Results will
        be converted from this convention to COCOS 1. Possible values are between 1
        to 8, or between 11 to 18.
    eq_type: Optional[str]
        A label denoting the type of Equilibrium, such as "GEQDSK", "TRANSP", "VMEC",
        etc.

    Attributes
    ----------

    data: xarray.Dataset
        The internal representation of the ``Equilibrium`` object. The functions
        ``__getattr__`` and ``__getitem__`` redirect most attribute/indexing lookups
        here, but the Dataset itself may be accessed directly by the user if they wish
        to perform more complex manipulations.
    R_axis: float, units [meter]
        Major radius position of the magnetic axis.
    Z_axis: float, units [meter]
        Vertical position of the magnetic axis, in meters.
    psi_axis: float, units [weber / radian]
        Poloidal magnetic flux function :math:`\psi` on the magnetic axis.
    psi_lcfs: float, units [weber / radian]
        Poloidal magnetic flux function :math:`\psi` on the last closed flux surface.
    a_minor: float, units [meter]
        Minor radius of the last closed flux surface.
    dR: float, units [meter]
        Grid spacing in the radial direction.
    dZ: float, units [meter]
        Grid spacing in the vertical direction.
    eq_type: str
        Type of equilibrium.

    See Also
    --------
    read_equilibrium: Create ``Equilibrium`` from a file.
    FluxSurface: An individual flux surface created from an ``Equilibrium``.

    Notes
    -----

    The Grad-Shafranov equation [1]_ may be written:

    .. math::
        \frac{\partial^2 \psi}{\partial r^2}
        - \frac{1}{r}\frac{\partial\psi}{\partial r}
        + \frac{\partial^2 \psi}{\partial z^2}
        = -\mu_0 r^2 p'(\psi) - f(\psi)f'(\psi)

    The :math:`r` coordinate is the major radius, the distance from the central column
    of a tokamak, and :math:`z` is the height within the tokamak (often defined as the
    vertical distance about the tokamak midplane, but other reference points may be used
    instead).

    :math:`\psi` is the poloidal magnetic flux function, defined as:

    .. math::
        \vec{B_p} = \frac{1}{r} \nabla\psi \times \hat{\phi}

    where :math:`\vec{B_p}` is the poloidal magnetic field vector, and
    :math:`\hat{\phi}` is the unit vector in the toroidal direction. :math:`\psi` is
    arbitrary to within an additive constant. :math:`f` is the poloidal current
    function, and is defined similarly:

    .. math::
        \vec{J_p} = \frac{\mu_0}{r} \nabla f \times \hat{\phi}

    where :math:`\vec{J_p}` is the poloidal current density. It may be shown that
    :math:`f` is a function of :math:`\psi` only, as is the plasma pressure, :math:`p`.
    Along with the safety factor, :math:`q(\psi)`:

    .. math::
        q = \frac{1}{2\pi}\oint \frac{1}{r} \frac{B_\phi}{B_p} ds

    which describes the number of times a magnetic field line wraps around the toroidal
    direction before arriving at the same point in the poloidal plane, these quantities
    describe a plasma equilibrium in full.

    For gyrokinetics simulations, it is common for researchers to make use of the
    normalised :math:`\psi_n`, which is scaled so that :math:`\psi_n=0` at the magnetic
    axis, and :math:`\psi_n=1` at the Last Closed Flux Surface (LCFS).

    .. [1] J. Wesson and D.J. Campbell: "Tokamaks", Oxford University Press, 2011,
        chapter 3
    """

    # Instance of reader factory
    # Classes which can read equilibrium files (G-EQDSK, TRANSP, etc) are registered
    # to this using the `equilibrium_reader` decorator below.
    _readers = create_reader_factory()

    # This dict defines the units for each argument to __init__.
    # The values are passed to the units.wraps decorator.
    _init_units = {
        "self": None,
        "R": eq_units["len"],
        "Z": eq_units["len"],
        "psi_RZ": eq_units["psi"],
        "psi": eq_units["psi"],
        "f": eq_units["f"],
        "ff_prime": eq_units["ff_prime"],
        "p": eq_units["p"],
        "p_prime": eq_units["p_prime"],
        "q": eq_units["q"],
        "R_major": eq_units["len"],
        "r_minor": eq_units["len"],
        "Z_mid": eq_units["len"],
        "psi_lcfs": eq_units["psi"],
        "a_minor": eq_units["len"],
        "b_axis": eq_units["b"],
        "current": eq_units["i"],
        "clockwise_phi": None,
        "cocos": None,
        "eq_type": None,
    }

    @units.wraps(None, [*_init_units.values()], strict=False)
    def __init__(
        self,
        R: ArrayLike,
        Z: ArrayLike,
        psi_RZ: ArrayLike,
        psi: ArrayLike,
        f: ArrayLike,
        ff_prime: ArrayLike,
        p: ArrayLike,
        p_prime: ArrayLike,
        q: ArrayLike,
        R_major: ArrayLike,
        r_minor: ArrayLike,
        Z_mid: ArrayLike,
        psi_lcfs: float,
        a_minor: float,
        b_axis: Optional[float] = None,
        current: Optional[float] = None,
        clockwise_phi: bool = False,
        cocos: Optional[int] = None,
        eq_type: Optional[str] = None,
    ) -> None:
        # Determine COCOS convention
        if cocos is not None:
            # User has asserted the input COCOS convention
            cocos_in = cocos
        elif b_axis is not None and current is not None:
            # Detect the input COCOS convention
            cocos_in = identify_cocos(
                b_axis, current, q, psi, clockwise_phi=clockwise_phi, a=r_minor
            )[0]
            if cocos_in != 1:
                warnings.warn(
                    f"Detected inputs have COCOS {cocos_in}. Converting to 1.",
                    EquilibriumCOCOSWarning,
                )
        else:
            # Assume the input COCOS convention is already 1
            cocos_in = 1
        cocos_factors = cocos_transform(cocos_in, 1)

        # Check the grids R, Z, and psi_RZ
        R = np.asfarray(R) * eq_units["len"]
        Z = np.asfarray(Z) * eq_units["len"]
        psi_RZ = np.asfarray(psi_RZ) * cocos_factors["PSI"] * eq_units["psi"]
        # Check that r and z are linearly spaced and increasing 1D grids
        for name, grid in {"R": R, "Z": Z}.items():
            if len(grid.shape) != 1:
                raise ValueError(f"The grid {name} must be 1D.")
            diff = np.diff(grid)
            if not np.allclose(diff, diff[0]):
                raise ValueError(f"The grid {name} must linearly spaced.")
            if diff[0] <= 0.0:
                raise ValueError(f"The grid {name} must have a positive spacing.")
        # Check that psi_RZ has the correct dimensions
        shape_2d = (len(R), len(Z))
        if not np.array_equal(psi_RZ.shape, shape_2d):
            raise ValueError(
                f"The grid psi_RZ has shape {psi_RZ.shape}. "
                f"It should have shape {shape_2d}."
            )

        # Create bivariate spline and partial derivatives over psi_RZ
        self._psi_RZ_spline = UnitSpline2D(R, Z, psi_RZ)

        # Check the psi grids
        psi = np.asfarray(psi) * cocos_factors["PSI"] * eq_units["psi"]
        f = np.asfarray(f) * cocos_factors["F"] * eq_units["f"]
        ff_prime = (
            np.asfarray(ff_prime) * cocos_factors["F_FPRIME"] * eq_units["ff_prime"]
        )
        p = np.asfarray(p) * eq_units["p"]
        p_prime = np.asfarray(p_prime) * cocos_factors["PPRIME"] * eq_units["p_prime"]
        q = np.asfarray(q) * cocos_factors["Q"] * eq_units["q"]
        R_major = np.asfarray(R_major) * eq_units["len"]
        r_minor = np.asfarray(r_minor) * eq_units["len"]
        Z_mid = np.asfarray(Z_mid) * eq_units["len"]
        # Ensure psi is 1D and monotonically increasing
        if len(psi.shape) != 1:
            raise ValueError("The grid psi must be 1D.")
        if np.any(np.diff(psi) <= 0):
            raise ValueError("The grid psi must have a positive spacing.")
        # Ensure all psi grids have the correct shape
        psi_grids = {
            "f": f,
            "ff_prime": ff_prime,
            "p": p,
            "p_prime": p_prime,
            "q": q,
            "R_major": R_major,
            "r_minor": r_minor,
            "Z_mid": Z_mid,
        }
        psi_shape = psi.shape
        for name, grid in psi_grids.items():
            if not np.array_equal(grid.shape, psi_shape):
                raise ValueError(
                    f"The grid {name} has shape {grid.shape}. "
                    f"It should have shape {psi_shape}."
                )

        # Check that floats are valid
        psi_lcfs = float(psi_lcfs) * cocos_factors["PSI"] * eq_units["psi"]
        if psi_lcfs < psi[0]:
            raise ValueError("psi_lcfs should be greater than psi[0].")
        a_minor = float(a_minor) * eq_units["len"]
        if a_minor <= 0.0:
            raise ValueError("a_minor should be a positive float.")

        # Check r_minor and create normalised version 'rho'
        if r_minor[0] != 0.0:
            raise ValueError("r_minor[0] should be zero.")
        if np.any(np.diff(r_minor) <= 0):
            raise ValueError("The grid r_minor must have a positive spacing.")
        rho = r_minor / a_minor

        # Create normalised 1d psi grid
        psi_n = (psi - psi[0]) / (psi_lcfs - psi[0])

        # Create spline functions for all psi grids with respect to psi
        self._f_psi_spline = UnitSpline(psi, f)
        self._ff_prime_psi_spline = UnitSpline(psi, ff_prime)
        self._p_psi_spline = UnitSpline(psi, p)
        self._p_prime_psi_spline = UnitSpline(psi, p_prime)
        self._q_psi_spline = UnitSpline(psi, q)
        self._R_major_psi_spline = UnitSpline(psi, R_major)
        self._r_minor_psi_spline = UnitSpline(psi, r_minor)
        self._Z_mid_psi_spline = UnitSpline(psi, Z_mid)

        # Assemble grids into underlying xarray Dataset
        def make_var(dim, val, desc):
            return (dim, val, {"units": str(val.units), "long_name": desc})

        coords = {
            "R": make_var("R_dim", R, "R Major Position"),
            "Z": make_var("Z_dim", Z, "Vertical Position"),
            "psi": make_var("psi_dim", psi, "Poloidal Flux"),
        }

        data_vars = {
            "psi_RZ": make_var(("R_dim", "Z_dim"), psi_RZ, "Poloidal Flux"),
            "f": make_var("psi_dim", f, "Poloidal Current"),
            "ff_prime": make_var("psi_dim", ff_prime, "ff'"),
            "p": make_var("psi_dim", p, "Plasma Pressure"),
            "p_prime": make_var("psi_dim", p_prime, "p'(psi)"),
            "q": make_var("psi_dim", q, "Safety Factor"),
            "R_major": make_var("psi_dim", R_major, "Flux Surface Radial Midpoint"),
            "r_minor": make_var("psi_dim", r_minor, "Flux Surface Width"),
            "Z_mid": make_var("psi_dim", Z_mid, "Flux Surface Vertical Midpoint"),
            "rho": make_var("psi_dim", rho, "Normalised Flux Surface Width"),
            "psi_n": make_var("psi_dim", psi_n, "Normalised Poloidal Flux"),
        }

        attrs = {
            "R_axis": R_major[0],
            "Z_axis": Z_mid[0],
            "psi_axis": psi[0],
            "psi_lcfs": psi_lcfs,
            "a_minor": a_minor,
            "dR": R[1] - R[0],
            "dZ": Z[1] - Z[0],
            "eq_type": str(eq_type),
        }
        if b_axis is not None:
            attrs["b_axis"] = b_axis * cocos_factors["BT"] * eq_units["b"]
        if current is not None:
            attrs["current"] = current * cocos_factors["IP"] * eq_units["i"]

        super().__init__(data_vars=data_vars, coords=coords, attrs=attrs)

    @units.wraps(eq_units["psi"], (None, units.dimensionless), strict=False)
    def psi(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return actual poloidal magnetic flux function :math:`\psi` for a given
        normalised :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]
            Normalised poloidal magnetic flux function, scaled such that
            :math:`\psi_n=0` on the magnetic axis and :math:`\psi_n=1` on the last
            closed flux surface. Results are undefined outside this range.

        Returns
        -------
        np.ndarray, units [weber / radian]
            Actual poloidal magnetic flux. Note that the result is arbitrary within an
            additive constant.
        """
        # units introduced via self.psi_axis and self.psi_lcfs
        return self.psi_axis + np.asanyarray(psi_n) * (self.psi_lcfs - self.psi_axis)

    @units.wraps(units.dimensionless, (None, eq_units["psi"]), strict=False)
    def psi_n(self, psi: ArrayLike) -> np.ndarray:
        r"""
        Return normalised poloidal magnetic flux function :math:`\psi_n` for a given
        actual :math:`\psi`.

        Parameters
        ----------
        psi: ArrayLike, units [weber / radian]
            Actual poloidal magnetic flux. Note that the result is arbitrary within an
            additive constant.

        Returns
        -------
        np.ndarray, units [dimensionless]
            Normalised poloidal magnetic flux function, scaled such that
            :math:`\psi_n=0` on the magnetic axis and :math:`\psi_n=1` on the last
            closed flux surface. Results are undefined outside this range.
        """
        psi = np.asanyarray(psi) * eq_units["psi"]
        return (psi - self.psi_axis) / (self.psi_lcfs - self.psi_axis)

    @units.wraps(eq_units["f"], (None, units.dimensionless), strict=False)
    def f(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return poloidal current function :math:`f` at the normalised poloidal magnetic
        flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter * tesla]
        """
        return self._f_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["ff_prime"], (None, units.dimensionless), strict=False)
    def ff_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return poloidal current function :math:`f` multiplied by its derivative with
        respect to :math:`\psi` for a given normalised poloidal magnetic flux function
        :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter**2 * tesla**2 * radian / weber]
        """
        return self._ff_prime_psi_spline(self.psi(psi_n))

    def f_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return derivative of the poloidal current function :math:`f` with respect to
        :math:`\psi` for a given normalised poloidal magnetic flux function
        :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter * tesla * radian / weber]
        """
        # Note: Does not need units.wraps, as both self.f and self.ff_prime do instead
        return self.ff_prime(psi_n) / self.f(psi_n)

    @units.wraps(eq_units["p"], (None, units.dimensionless), strict=False)
    def p(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return plasma pressure for a given normalised poloidal magnetic flux function
        :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [pascal]
        """
        return self._p_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["p_prime"], (None, units.dimensionless), strict=False)
    def p_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return derivative of the plasma pressure with respect to :math:`\psi` for a
        given normalised poloidal magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [pascal * radian / weber]
        """
        return self._p_prime_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["q"], (None, units.dimensionless), strict=False)
    def q(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the safety factor for a given normalised poloidal magnetic flux function
        :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [dimensionless]
        """
        return self._q_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["q_prime"], (None, units.dimensionless), strict=False)
    def q_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the derivative of the safety factor with respect to :math:`\psi` for a
        given normalised poloidal magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [radian / weber]
        """
        return self._q_psi_spline(self.psi(psi_n), derivative=1)

    @units.wraps(eq_units["len"], (None, units.dimensionless), strict=False)
    def R_major(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the major radius position of the midpoint of the flux surface represented
        by a given normalised poloidal magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter]
        """
        return self._R_major_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["len_prime"], (None, units.dimensionless), strict=False)
    def R_major_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return derivative with respect to :math:`\psi` of the major radius position of
        the midpoint of the flux surface represented by a given normalised poloidal
        magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter * radian / weber]
        """
        return self._R_major_psi_spline(self.psi(psi_n), derivative=1)

    @units.wraps(eq_units["len"], (None, units.dimensionless), strict=False)
    def r_minor(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return half of the width of the flux surface represented by a given normalised
        poloidal magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter]
        """
        return self._r_minor_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["len_prime"], (None, units.dimensionless), strict=False)
    def r_minor_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return derivative with respect to :math:`\psi` of the width of the flux surface
        represented by a given normalised poloidal magnetic flux function
        :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter * radian / weber]
        """
        return self._r_minor_psi_spline(self.psi(psi_n), derivative=1)

    @units.wraps(eq_units["len"], (None, units.dimensionless), strict=False)
    def Z_mid(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the vertical position of the midpoint of the flux surface represented by
        a given normalised poloidal magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter]
        """
        return self._Z_mid_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["len_prime"], (None, units.dimensionless), strict=False)
    def Z_mid_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the derivative with respect to :math:`\psi` of the vertical position of
        the midpoint of the flux surface represented by a given normalised poloidal
        magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter * radian / weber]
        """
        return self._Z_mid_psi_spline(self.psi(psi_n), derivative=1)

    def rho(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the normalised minor radius of the flux surface represented by a given
        normalised poloidal magnetic flux function :math:`\psi_n`. This is the same as
        ``r_minor/a_minor``.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [dimensionless]
        """
        # Note: does not need to use units.wraps, as it defers to self.r_minor
        return self.r_minor(psi_n) / self.a_minor

    @units.wraps(eq_units["b"], (None, eq_units["len"], eq_units["len"]), strict=False)
    def b_radial(self, R: ArrayLike, Z: ArrayLike) -> np.ndarray:
        r"""
        Return the radial magnetic flux density at the position(s) ``(R, Z)``.

        Parameters
        ----------
        R: ArrayLike, units [meter]
            Major radius positions.
        Z: ArrayLike, units [meter]
            Vertical positions. Should have the same shape as ``R``, or be broadcastable
            to ``R``.

        Returns
        -------
        np.ndarray, units [tesla]
        """
        R = np.asanyarray(R) * eq_units["len"]
        Z = np.asanyarray(Z) * eq_units["len"]
        return -self._psi_RZ_spline(R, Z, dy=1) / R

    @units.wraps(eq_units["b"], (None, eq_units["len"], eq_units["len"]), strict=False)
    def b_vertical(self, R: ArrayLike, Z: ArrayLike) -> np.ndarray:
        r"""
        Return the vertical magnetic flux density at the position(s) ``(R, Z)``.

        Parameters
        ----------
        R: ArrayLike, units [meter]
            Major radius positions.
        Z: ArrayLike, units [meter]
            Vertical positions. Should have the same shape as ``R``, or be broadcastable
            to ``R``.

        Returns
        -------
        np.ndarray, units [tesla]
        """
        R = np.asanyarray(R) * eq_units["len"]
        Z = np.asanyarray(Z) * eq_units["len"]
        return self._psi_RZ_spline(R, Z, dx=1) / R

    @units.wraps(eq_units["b"], (None, eq_units["len"], eq_units["len"]), strict=False)
    def b_poloidal(self, R: ArrayLike, Z: ArrayLike) -> np.ndarray:
        r"""
        Return the magnitude of the polooidal magnetic flux density at the position(s)
        ``(R, Z)``.

        Parameters
        ----------
        R: ArrayLike, units [meter]
            Major radius positions.
        Z: ArrayLike, units [meter]
            Vertical positions. Should have the same shape as ``R``, or be broadcastable
            to ``R``.

        Returns
        -------
        np.ndarray, units [tesla]
        """
        return np.hypot(self.b_radial(R, Z), self.b_vertical(R, Z))

    @units.wraps(eq_units["b"], (None, eq_units["len"], eq_units["len"]), strict=False)
    def b_toroidal(self, R: ArrayLike, Z: ArrayLike) -> np.ndarray:
        r"""
        Return the toroidal magnetic flux density at the position(s) ``(R, Z)``.

        Parameters
        ----------
        R: ArrayLike, units [meter]
            Major radius positions.
        Z: ArrayLike, units [meter]
            Vertical positions. Should have the same shape as ``R``, or be broadcastable
            to ``R``.

        Returns
        -------
        np.ndarray, units [tesla]
        """
        R = np.asanyarray(R) * eq_units["len"]
        Z = np.asanyarray(Z) * eq_units["len"]
        # Get psi along the path, use this to get f
        psi = self._psi_RZ_spline(R, Z)
        return self.f(self.psi_n(psi)) / R

    def flux_surface(self, psi_n: float) -> FluxSurface:
        r"""
        Generate a FluxSurface object representing the flux surface with normalised
        poloidal magnetic flux function :math:`\psi_n`. This Dataset-like object
        contains information such as the path swept out by the flux surface in
        ``(R, z)`` coordinates, the magnetic flux density along the path, and
        quantities such as pressure, safety factor, the poloidal current function
        :math:`f`, and their derivatives with respect to :math:`\psi` on the flux
        surface. It also contains derivatives with respect to the minor radius of
        the flux surface, and normalised versions of :math:`\psi`
        """
        # Get rz contours
        # (the 'wraps' decorator used by _flux_surface_contour does not recognise
        # xarray DataArrays)
        R, Z = _flux_surface_contour(
            self["R"].data,
            self["Z"].data,
            self["psi_RZ"].data,
            self.R_axis,
            self.Z_axis,
            self.psi(psi_n),
        )

        # Get magnetic field quantities around the contour path
        b_poloidal = self.b_poloidal(R, Z)

        # Get attributes on the flux surface
        R_major = self.R_major(psi_n)
        r_minor = self.r_minor(psi_n)
        Z_mid = self.Z_mid(psi_n)
        f = self.f(psi_n)
        p = self.p(psi_n)
        q = self.q(psi_n)
        R_major_prime = self.R_major_prime(psi_n)
        r_minor_prime = self.r_minor_prime(psi_n)
        Z_mid_prime = self.Z_mid_prime(psi_n)
        p_prime = self.p_prime(psi_n)
        q_prime = self.q_prime(psi_n)

        magnetic_shear = (r_minor / q) * (q_prime / r_minor_prime)
        shafranov_shift = R_major_prime / r_minor_prime
        midplane_shift = Z_mid_prime / r_minor_prime
        pressure_gradient = p_prime / r_minor_prime
        psi_gradient = 1.0 / r_minor_prime

        return FluxSurface(
            R=R,
            Z=Z,
            b_poloidal=b_poloidal,
            R_major=R_major,
            r_minor=r_minor,
            Z_mid=Z_mid,
            f=f,
            p=p,
            q=q,
            magnetic_shear=magnetic_shear,
            shafranov_shift=shafranov_shift,
            midplane_shift=midplane_shift,
            pressure_gradient=pressure_gradient,
            psi_gradient=psi_gradient,
            a_minor=self.a_minor,
        )

    def plot(
        self,
        quantity: str,
        ax: Optional[plt.Axes] = None,
        psi_n: bool = False,
        show: bool = False,
        x_label: Optional[str] = None,
        y_label: Optional[str] = None,
        **kwargs,
    ) -> plt.Axes:
        r"""
        Plot a quantity defined on the :math:`\psi` grid.

        Parameters
        ----------
        quantity: str
            Name of the quantity to plot. Must be defined over the grid ``psi``.
        ax: Optional[plt.Axes]
            Axes object on which to plot. If not provided, a new figure is created.
        psi_n: bool, default False
            If True, plot against normalised :math:`\psi_n`. Otherwise, plot against
            :math:`\psi`.
        show: bool, default False
            Immediately show Figure after creation.
        x_label: Optional[str], default None
            Overwrite the default x label. Set to an empty string ``""`` to disable.
        y_label: Optional[str], default None
            Overwrite the default y label. Set to an empty string ``""`` to disable.
        **kwargs
            Additional arguments to pass to Matplotlib's ``plot`` call.

        Returns
        -------
        plt.Axes
            The Axes object created after plotting.

        Raises
        ------
        ValueError
            If ``quantity`` is not a quantity defined over the :math:`\psi` grid,
            or is not the name of an Equilibrium quantity.
        """
        if quantity not in self.data_vars:
            raise ValueError(
                f"Must be provided with a quantity defined on the psi grid."
                f"The quantity '{quantity}' is not recognised."
            )

        quantity_dims = self[quantity].dims
        if "psi_dim" not in quantity_dims or len(quantity_dims) != 1:
            raise ValueError(
                f"Must be provided with a quantity defined on the psi grid."
                f"The quantity '{quantity}' has coordinates {quantity_dims}."
            )

        if ax is None:
            _, ax = plt.subplots(1, 1)

        x_data = self["psi_n" if psi_n else "psi"]
        if x_label is None:
            x_label = x_data.long_name
            if x_data.data.units != "":
                x_label += f" / ${x_data.data.units:L~}$"

        y_data = self[quantity]
        if y_label is None:
            y_label = y_data.long_name
            if y_data.data.units != "":
                y_label += f" / ${y_data.data.units:L~}$"

        ax.plot(x_data.data.magnitude, y_data.data.magnitude, **kwargs)
        if x_label != "":
            ax.set_xlabel(x_label)
        if y_label != "":
            ax.set_ylabel(y_label)

        if show:
            plt.show()

        return ax

    def contour(
        self,
        ax: Optional[plt.Axes] = None,
        cbar: bool = True,
        aspect: bool = False,
        show: bool = False,
        x_label: Optional[str] = None,
        y_label: Optional[str] = None,
        z_label: Optional[str] = None,
        **kwargs,
    ) -> plt.Axes:
        r"""
        Plot :math:`\psi` over the :math:`(R, Z)` grid using a 2D coloured contour plot.
        Uses Matplotlib's ``contourf``.

        Parameters
        ----------
        ax: Optional[plt.Axes]
            Axes object on which to plot. If not provided, a new figure is created.
        cbar: bool, default True
            If True, builds a colourbar next to the generated plot.
        aspect: bool, default False
            If True, ensures the axes have the correct aspect ratio. If the user
            supplies their own ``ax``, has no effect.
        show: bool, default False
            Immediately show Figure after creation.
        x_label: Optional[str], default None
            Overwrite the default x label. Set to an empty string ``""`` to disable.
        y_label: Optional[str], default None
            Overwrite the default y label. Set to an empty string ``""`` to disable.
        z_label: Optional[str], default None
            Overwrite the default colorbar label. Set to an empty string ``""`` to
            disable. Ignored if ``cbar`` is False.
        **kwargs
            Additional arguments to pass to Matplotlib's ``contourf`` call.

        Returns
        -------
        plt.Axes
            The Axes object created after plotting.
        """

        if ax is None:
            _, ax = plt.subplots(1, 1)
            if aspect:
                ax.set_aspect("equal")

        x_data = self["R"]
        if x_label is None:
            x_label = f"{x_data.long_name} / ${x_data.data.units:L~}$"

        y_data = self["Z"]
        if y_label is None:
            y_label = f"{y_data.long_name} / ${y_data.data.units:L~}$"

        z_data = self["psi_RZ"]
        if z_label is None:
            z_label = f"{z_data.long_name} / ${z_data.data.units:L~}$"

        x_grid, y_grid = np.meshgrid(
            x_data.data.magnitude, y_data.data.magnitude, indexing="ij"
        )

        im = ax.contourf(x_grid, y_grid, z_data.data.magnitude, **kwargs)
        ax.set_xlabel(x_label)
        ax.set_ylabel(y_label)

        if cbar:
            fig = ax.get_figure()
            colorbar = fig.colorbar(im, ax=ax)
            colorbar.set_label(z_label)

        if show:
            plt.show()

        return ax

    @classmethod
    def reader(cls, key: str) -> Callable:
        r"""
        Decorator for classes that inherit Reader and create Equilibrium objects.
        Registers classes with the global factory, and sets the class-level attribute
        'file_type' to the provided key. Can be used to register user-created plugins
        for equilibrium file readers.

        Parameters
        ----------
        key: str
            The registered name for the Reader class. When building Equilibrium from a
            file using ``from_file``, the optional ``eq_type`` argument will correspond
            to this name.

        Returns
        -------
        Callable
            The decorator function that registers the class with the
            ``Equilibrium._readers`` factory.

        Examples
        --------

        ::

            # Use this to decorate classes which inherit Reader and define the functions
            # 'read' and (optionally) 'verify'. Provide a key that will be used as an
            # identifier.
            @Equilibrium.reader("MyEquilibrium")
            class MyEquilibriumReader(Reader):

                def read(self, path):
                    pass

                def verify(self, path):
                    pass

            # MyEquilibriumReader will now contain the 'file_type' attribute
            assert MyEquilibriumReader.file_type == "MyEquilibrium"

            # The user can now read files of this type
            eq = Equilibrium.from_file("MyEquilibrium.txt", eq_type="MyEquilibrium")
        """

        def decorator(t: Type[Reader]) -> Type[Reader]:
            cls._readers[key] = t
            t.file_type = key
            return t

        return decorator

    @classmethod
    def from_file(
        cls,
        path: PathLike,
        eq_type: Optional[str] = None,
        **kwargs,
    ):
        r"""
        Read a plasma equilibrium file from disk, returning an ``Equilibrium`` instance.

        Parameters
        ----------
        path: PathLike
            Location of the equilibrium file on disk.
        eq_type: Optional[str]
            String specifying the type of equilibrium file. If unset, the file type will
            be inferred automatically. Specifying the file type may improve performance.
        **kwargs:
            Keyword arguments forwarded to the equilibrium file reader.

        Returns
        -------
        Equilibrium

        Raises
        ------
        ValueError
            If ``path`` does not refer to a valid file.
        RuntimeError
            If ``eq_type`` is unset, and it is not possible to infer the file type
            automatically.
        """
        path = Path(path)
        if not path.is_file():
            raise ValueError(f"File {path} not found.")
        # Infer reader type from path if not provided with eq_type
        reader = cls._readers[path if eq_type is None else eq_type]
        eq = reader(path, **kwargs)
        if not isinstance(eq, cls):
            raise RuntimeError("Equilibrium reader did not return an Equilibrium")
        return eq

    @classmethod
    def supported_types(cls):
        """
        Returns a list of all registered Equilibrium file types. These file types are
        readable by ``from_file``.
        """
        return [*cls._readers]

    def __deepcopy__(self, memodict):
        """Copy Equilibrium object in full, following references down the stack."""
        # Create new object without calling __init__
        new_equilibrium = Equilibrium.__new__(Equilibrium)
        # Deep copy each member individually
        for key, value in vars(self).items():
            setattr(new_equilibrium, key, deepcopy(value, memodict))
        return new_equilibrium


@Equilibrium.reader("Pyrokinetics")
class EquilibriumReaderPyro(Reader):
    """
    An Equilibrium reader class for netcdf files generated from Pyrokinetics Equilibrium
    objects. These can be created using ``eq.to_netcdf("my_filename.nc")``.
    """

    def read(self, filename: PathLike, **kwargs) -> Equilibrium:
        self.verify(filename)
        eq = Equilibrium.from_netcdf(filename, **kwargs)
        if eq.software_version != __version__:
            warnings.warn(
                dedent(
                    f"""\
                    Pyrokinetics Equilibrium object {filename} may not be compatible.
                    It was created with version {eq.software_version}, while this is
                    version {__version__}.
                    """
                )
            )
        return eq

    def verify(self, filename: PathLike) -> None:
        ds = xr.open_dataset(filename)
        if ds.software_name != "Pyrokinetics":
            raise ValueError
        if ds.object_type != "Equilibrium":
            raise ValueError


# Plain function versions of Equilibrium classmethods:


def read_equilibrium(
    path: PathLike,
    eq_type: Optional[str] = None,
    **kwargs,
) -> Equilibrium:
    r"""
    A plain-function alternative to ``Equilibrium.from_file``.
    """
    return Equilibrium.from_file(path, eq_type=eq_type, **kwargs)


def equilibrium_reader(key: str) -> Callable:
    r"""
    A plain-function alternative to ``Equilibrium.reader``.
    """
    return Equilibrium.reader(key)


def supported_equilibrium_types() -> List[str]:
    r"""
    A plain-function alternative to ``Equilibrium.supported_types``.
    """
    return Equilibrium.supported_types()
